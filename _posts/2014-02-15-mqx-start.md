---
layout: post
title: "MQX机制分析——启动流程"
description: ""
categories: 
- C
tags: [MQX,操作系统,飞思卡尔]
---
{% include JB/setup %}

　　接着上一个hello world的工程，我们点开hello_twrk60n512工程中的hello.c，发现并没有我们平时所看到的的裸奔程序不太一样，怎么连个main函数都找不到，更别说系统启动代码了，不要急，首先我们先要找到链接文件。链接文件就是用来指明链接各个目标文件的规则了，工程下面不同的源文件会生成不同的目标文件，链接的过程会把这些链接文件链接成最终的可执行文件，链接文件里面会定义一些segment（段），表明芯片存储范围的分配，rom、ram、中断向量表等等的地址范围，以及不同的目标文件的相同段如何合并以及他们的存放位置（MQX的lcf文件在后面会单独详细介绍）。浏览了下..\Freescale_MQX_4_0\lib\twrk60n512.cw10\debug\bsp目录下的intflash.lcf链接文件，发现没有定义程序的入口，以前ld格式的链接文件里面是有指定程序入口的，可是在lcf文件怎么没找到？再想想其他办法，在开发环境的链接器的选项也有指定程序入口的，我们右击工程，选择呢properties，点到c/c++ Build标签下的Link下面，发现还是没有指定程序入口，怎么办？继续想，对了，我们可以找到中断向量表，因为中断向量表的第二项存的是复位向量的地址，根据cortex m3/4的特性，cpu复位时，会从中断向量表的起始地址（在之前[这篇文章](http://jeremybai.github.io/blog/2014/01/13/compiler/)有讲过，这里的起始地址不一定是0x0000_0000）取出堆栈指针SP，从下一个32位的空间处取出复位中断入口向量。目标有了，我们现在要找到定义中断向量表的文件，终于！！！我们发现在..\Freescale_MQX_4_0\mqx\source\bsp\twrk60n512文件夹目录下的vectors.c中的中断向量表定义的中断向量表：  
{% highlight c++ %}
__attribute__((section(".vectors_rom"))) const vector_entry __vector_table[256] __attribute__((used)) = 
{
    (vector_entry)__BOOT_STACK_ADDRESS,
    BOOT_START,         /* 0x01  0x00000004   -   ivINT_Initial_Program_Counter */
    DEFAULT_VECTOR,     /* 0x02  0x00000008   -   ivINT_NMI                     */
    DEFAULT_VECTOR,     /* 0x03  0x0000000C   -   ivINT_Hard_Fault              */
    DEFAULT_VECTOR,     /* 0x04  0x00000010   -   ivINT_Mem_Manage_Fault        */
    DEFAULT_VECTOR,     /* 0x05  0x00000014   -   ivINT_Bus_Fault               */
    DEFAULT_VECTOR,     /* 0x06  0x00000018   -   ivINT_Usage_Fault             */
    0,                  /* 0x07  0x0000001C   -   ivINT_Reserved7               */
    0,                  /* 0x08  0x00000020   -   ivINT_Reserved8               */
    0,                  /* 0x09  0x00000024   -   ivINT_Reserved9               */
    0,                  /* 0x0A  0x00000028   -   ivINT_Reserved10              */
    _svc_handler,       /* 0x0B  0x0000002C   -   ivINT_SVCall                  */
    DEFAULT_VECTOR,     /* 0x0C  0x00000030   -   ivINT_DebugMonitor            */
    0,                  /* 0x0D  0x00000034   -   ivINT_Reserved13              */
    _pend_svc,          /* 0x0E  0x00000038   -   ivINT_PendableSrvReq          */
    DEFAULT_VECTOR,     /* 0x0F  0x0000003C   -   ivINT_SysTick                 */
    /* Cortex external interrupt vectors                                        */
    DEFAULT_VECTOR,     /* 0x10  0x00000040   -   ivINT_DMA0                    */
    DEFAULT_VECTOR,     /* 0x11  0x00000044   -   ivINT_DMA1                    */
    DEFAULT_VECTOR,     /* 0x12  0x00000048   -   ivINT_DMA2                    */
...
{% endhighlight %}  
　　\_\_attribute\_\_((section(".vectors_rom")))这句话的意思是在表明装载编译生成目标文件的时候将它放在.vectors_rom这个段中。\_\_attribute\_\_是gcc的一个很大的特色，它可以用来设置函数属性、变量属性和类型属性，感兴趣的可以查看gcc相关的资料。vector_entry是之前定义的一个函数指针类型：`typedef void (*vector_entry)(void);`\_\_attribute\_\_((used))是 ARM 编译器支持的 GNU 编译器扩展，告诉编译器在目标文件中保留它，并且按照声明的顺序在目标文件中排列（[这边](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0348bc/BABCJJID.html)我也不是很明白=。=！，没看懂啥意思）。反正这个类型定义就是定义了一个const类型的数组，存放的数据是函数指针类型，编译完之后按顺序存放在目标文件的.vectors_rom段中。我们将注意力集中到第二项BOOT_START，这个名字看起来有点唬人，看起来像是程序入口，查看它的定义，发现是个宏定义：`#define BOOT_START __boot`。不过看起来好像快接近正确的结果了，找啊找，终于在..\Freescale_MQX_4_0\mqx\source\psp\cortex_m\core\M4目录下的boot.S找到了这个函数，没错了，这就是我们要找的程序启动的入口了（后来想起来，为啥不直接debug到程序入口处呢，一下子就找到了，省的这么费事）。一个程序入口也找了这么久，喝口水，压压惊，咱继续看下去。

　　首先分析__boot这个函数，程序中已经删除了不必要的一些预处理命令。
{% highlight c++ %}
ASM_PUBLIC_BEGIN(__boot)
ASM_PUBLIC_FUNC(__boot)
ASM_LABEL(__boot)
        //清中断使能寄存器和中断挂起寄存器
        ldr r0, =0xe000e180     //中断使能寄存器
        ldr r1, =0xe000e280     //中断挂起寄存器
        ldr r2, =0xffffffff     //要向寄存器中写的数
        mov r3, #8              //总共8组寄存器

ASM_LABEL(_boot_loop)
        cbz r3, _boot_loop_end
        str r2, [r0], #4        //将0xffffffff写入到r0里面存放的地址中，然后r0+4
        str r2, [r1], #4        //将0xffffffff写入到r1里面存放的地址中，然后r0+4
        sub r3, r3, #1          //循环8次
        b _boot_loop
ASM_LABEL(_boot_loop_end)
        //将MSP赋值给PSP
        mrs r0, MSP
        msr PSP, r0
        //CONTROL[1]写1，即使用PSP
        mrs r0, CONTROL
        orr r0, r0, #2
        msr CONTROL, r0
        isb #15//清空processor的流水线，确保在 ISB 指令完成后，才从高速缓存或内存中提取位于该指令后的所有其他指令。
		//调用EWL（Embedded Warrior Library）库里面的startup函数
        ASM_EXTERN(__thumb_startup)
        b ASM_PREFIX(__thumb_startup)
 ASM_PUBLIC_END(__boot)
{% endhighlight %}    
　　注释都已经写的很清楚了，这个函数所做的操作就是清中断使能寄存器和中断挂起寄存器、切换PSP（进程堆栈指针）和调用startup函数，这个函数是在EWL库中的，我们可以在` {InstallPath\MCU\ARM_EABI_Support\ewl\EWL_Runtime\Runtime_ARM\Source\startup.c`里面找到，在__thumb_startup函数中会跳转到main函数开始执行。找到main函数（..\Freescale_MQX_4_0\mqx\source\bsp\twrk60n512），发现main函数真短，就三句代码：  
{% highlight c++ %}
int main(void)
{
   extern const MQX_INITIALIZATION_STRUCT MQX_init_struct;
   _mqx( (MQX_INITIALIZATION_STRUCT_PTR) &MQX_init_struct );
   return 0;
}
{% endhighlight %}    
　　声明了一个初始化结构体（这个结构体我们不急着分析，在启动过程中会带着讲它），接着就调用\_mqx()函数了，所以，这个\_mqx()函数就是MQX的启动函数了，重头戏才刚刚开始。    
　　在介绍这个函数之前，首先要讲到一个不得不提的概念，就是**kernel data**（内核数据区），这个东西会伴随着我们整个的源码分析过程，几乎所有的函数都会使用到这个东西，那么这个kernel data究竟是什么呢？内核数据区在内存中的表现形式为一段内存，在代码中的表现形式为一个包含了若干内核相关信息的结构体kernel_data_struct，里面的成员变量用来表明MQX的状态和动态变量的，该结构体的成员数不是固定的，其中有些变量是根据用户的配置决定是否编译，所以内核数据区的大小不是固定的。在执行MQX初始化函数\_mqx()时，我们向其传递一个名为MQX_INITIALIZATION_STRUCT的结构体作为参数，这个结构体包含了初始化MQX的基本信息如处理器个数，中断堆栈大小等等，其中的成员变量`BSP_DEFAULT_START_OF_KERNEL_MEMORY`代表了kernel data所在内存的起始地址，该变量具体数值是在链接的时候定下来的（在lcf文件中有对它赋值），这个起始地址也就是内核数据区kernel_data_struct的起始地址。  

　　执行\_mqx()函数的过程中，程序会对这块内存区域赋值，也就是对kernel_data_struct其中的成员变量进行赋值。这块内存应该是被访问的最频繁的，因为以后所有涉及到与内核相关的操作都要从这块内存先要获得内核状态的相关信息。以轻量级事件为例，当创建一个事件时，首先要调用_GET_KERNEL_DATA(kernel_data)函数获取内核信息，找到KERNEL_DATA_STRUCT结构中LWEVENTS这个成员，它代表了存储轻量级事件的队列的头。遍历这个队列，查看当前创建的轻量级事件在不在这个队列中，如果已经存在的话就返回错误，如果没有就将它压入内核数据中的轻量级事件队列中。

　　这里的_GET_KERNEL_DATA是一个宏定义：
{% highlight c++ %}
//_mqx_kernel_data 定义
KERNEL_ACCESS struct kernel_data_struct _PTR_ _mqx_kernel_data = (pointer)-1;
//_GET_KERNEL_DATA 宏定义
#define _GET_KERNEL_DATA(x)     x = _mqx_kernel_data
//_SET_KERNEL_DATA 宏定义
#define _SET_KERNEL_DATA(x)     _mqx_kernel_data = (struct kernel_data_struct _PTR_)(x)
{% endhighlight %}  
　　\_mqx_kernel_data就是内核数据区变量，当我需要需要获取内核数据的时候我就将它复制给我定义的变量就好了，如果我要设置它，就将我需要赋的值给这个变量，一般会在初始化\_mqx的时候会给它赋值，之后只需要读取内核数据就可以了。接下来开始看看\_mqx()函数做了什么。总的来说，它做了以下的工作，

