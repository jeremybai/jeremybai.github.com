---
layout: post
title: "MQX机制分析——中断机制"
description: ""
categories: 
- C
tags: [MQX,操作系统,飞思卡尔]
---
{% include JB/setup %}

## MQX中断机理剖析 ##
MQX对中断处理采取如下措施对中断请求进行动态管理：
（1）使用了静态和动态二张中断向量表；
（2）采用了内核ISR和用户ISR的分解处理机制；
（3）通过内核ISR把两张中断向量表联系在一起；
（4）采用了独立的系统中断栈，将系统中断栈与任务栈分开，提高了系统的安全性和稳定性。

第4点与Linux类似，在2.6以前的Linux内核版本中，中断处理程序是没有自己的栈的，他们共享的是所中断进程的内核栈（大小两页，32位体系结构是8KB，64位体系是16KB），使用起来会比较节约。之后在2.6早期的内核中，增加了一个选项，把栈的大小从两页减为一页，减少了内存的压力，但是这样中断所用的栈更很少了，于是中断处理程序就拥有了自己的栈，尽管大小只有原来的一半，但是平均可以利用的栈大了很多，因为中断处理程序可以使用整整一页。


两张中断向量表中，第一张可能是在rom（MQX_ROM_VECTORS=1）或者ram（MQX_ROM_VECTORS =0）中，其开始地址一般在链接文件（lcf文件）中指定，在给定的例程中将中断向量表存放在rom中，在MQX的lcf文件intflash.lcf中指定了rom中断向量表起始地址（__VECTOR_TABLE_ROM_START）为0x0000_0000处，该中断向量表的中断向量无法动态修改；第二张是申请的动态中断向量表，所有用户的自定义ISR可以在这张向量表上动态添加和修改。

## 动态中断向量表 ##
动态中断向量表是在哪里创建的呢？首先_mqx()对系统初始化中调用了_bsp_enable_card()函数初始化芯片外设，其次在初始化芯片外设中调用了_psp_int_init()中断初始化函数，再次在中断初始化函数中调用了_int_init( )函数，创建了动态中断向量表头节点并进行初始化。

动态中断向量表按HASH结构组织，如图3-2所示。动态中断向量表表项以8个向量为一组（8为缺省值分组值，可以修改）管理。系统初始化时根据给定的中断向量的数量除以8来确定动态中断向量表的组数，如251个中断可以分成251/8为32个组（进一法得到组数）。MQX系统初始化时调用了一个malloc函数为这32个成员申请一块连续的地址空间（数组成员为void*类型，每个指针为4字节），所以成员之间可以通过偏移一个队头节点大小（4字节）的空间进行寻址；而每个成员又是一个链表的头指针，链表各个表项节点地址不连续，每个链表项节点是独立的动态申请；通过链表项内的“NEXT”字段指针串成链表。MQX初始化时将每个组头节点的内容都初始设为NULL。链表节点内容由用户在安装中断服务例程时，调用_int_install_isr函数填充。链表节点包含了中断向量号，对应的ISR的指针，传递给ISR的参数以及链表中下一个中断向量表表项元素的指针等等。
[![1](http://a.hiphotos.bdimg.com/album/s%3D1400%3Bq%3D90/sign=be1fec7f3887e9504617f76820086832/d1160924ab18972bdc18e376e4cd7b899e510a6f.jpg)](http://a.hiphotos.bdimg.com/album/s%3D1400%3Bq%3D90/sign=be1fec7f3887e9504617f76820086832/d1160924ab18972bdc18e376e4cd7b899e510a6f.jpg)  

用户ISR由用户自定义编写，可以在运行时动态安装到MQX的中断处理系统中。如果用户需要实现一个ISR，只需要将该中断的中断号、该ISR的指针以及其他参数传递给_int_install_isr函数就行了。_int_install_isr函数将用户ISR与内核ISR绑定，它在动态中断向量表中根据参数中的中断号找到它所属的组（假如所要绑定中断的中断号为15，只需要计算（15-0）/8=1就可以得到它所在的组的地址为kernel_data->INTERRUPT_TABLE_PTR[1]，也就是第二组），然后遍历整个链表查找与它有着相同中断号的节点， 若没有，就添加新的表项；若已经存在，就将之前的ISR覆盖。所以即使重复安装一个中断的用户ISR，也不会使某一组中的表项个数超过8个，因为中断安装函数做的覆盖之前旧的用户ISR。