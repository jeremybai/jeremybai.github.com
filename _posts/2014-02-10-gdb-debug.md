---
layout: post
title: "如何使用GDB调试程序"
description: ""
categories: 
- C
tags: [调试]
---
{% include JB/setup %}
　　
## GDB是什么 ##
　　GDB是GNU开源组织发布的一个linux 系统上常用的 c/c++ 调试工具。之前工作环境一直在windows下，所以对图形化的调试方法比较熟悉，开始接触GDB的时候，觉得这样的调试方法简直“不可思议”，但是现在用下来觉得有点地方还是比图形化的调试更强大一点。GDB可以更容易地跟踪错误。比那些使用猜测蒙混过关的人无限量的printf。GDB是一个命令行工具，这意味着你可以与它交互终端 通过键盘发出命令，而不是用你的鼠标点击按钮。


　　要启动GDB，你真的只是键入gdb的提示和命中输入。 你会看到一些在屏幕上打印出来的你的版本，你正在运行的GDB， 它的版权信息，你会看到GDB提示：（GDB）。这让你知道，GDB准备的命令。在这一点上，最重要的是要知道该怎么退出。幸运的是，这是非常简单的。quit命令做到了这一点。作为一种快捷方式，你可以使用q。快速启动GDB，然后迅速退出，现在让我们来谈谈使用GDB调试程序。 

　　一般来说，GDB主要帮忙你完成下面四个方面的功能：

　　- 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。  
　　- 可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）。  
　　- 程序暂停时用户可以进行单步调试，用户可以随时查看程序中各表达式、变量值以及内存值，依此检查程序每步运行的结果是否跟预测值一致，并且可以检查每步出现的错误。  
　　- 动态的改变你程序的执行环境，用户可以改变程序中的变量或者执行顺序，来验证程序是否正确。

　　下面从这几个方面来介绍GDB。
## 1 GDB简单使用 ##
　　我们以一个简单例子来了解一下GDB的执行流程。下面一段代码是我翻之前的博客找到的。
{% highlight c++ %}
#include "stdio.h"
int main()
{
	char *charPtr = "I am the pointer of a string\n";
	int i = 10;
	double j = 3.14;
	int *intPtr =&i;
	double *floatPtr = &j;
	void *temp;
	temp = charPtr;
	printf("%s",(char*)temp);
	temp = intPtr;
	printf("%d\n",*(int*)temp);
	temp = floatPtr;
	printf("%f\n",*(double*)temp);
	return 0;
}
{% endhighlight %}
　　首先我们编译下源码，在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。  
　　并不是任何程序都可以使用GDB进行调试，要使用GDB进行调试必须满足两个条件：  
　　（1）程序必须使用GCC进行编译，并且在编译过程中添加“-g”调试信息选项。  
　　（2）要调试的可执行文件必须存在源程序代码，一般源程序代码存放的目录需要与可执行文件的目录相同。  
　　以上两个条件缺一不可，如果不添加-g选项，GDB将不能获取调试信息；如果缺少源程序代码，GDB将不能加载源文件并显示错误信息。  
　　在gcc编译时，因为使用优化会改变程序的运行结果，所以建议不要使用-O优化选项，这样才能使生成的可执行文件和源代码保持一一对应的关系；其次，用户如果想生成更多的调试信息，可在GCC编译时使用-ggdb选项。  
　　运行命令  `gcc -g <文件名> -o <生成可执行文件名>`  
　　然后启动GDB调试命令：`gdb <生成可执行文件名>` 。此时便进入了调试界面，屏幕上打印出来的你的版本，你正在运行的GDB， 它的版权信息等等。输入命令`list（l）`显示源码，便于你设置断点什么的。括号内为命令的缩写。    
![1](http://github-blog.qiniudn.com/2014-02-10-gdb-debug-1.png-BlogPic)
　　然后我们在程序第8行设置断点：`break 8(b 8)`，接着开始运行程序`run（r）`，程序执行到第8行时便会停止，你可以查看变量的信息，堆栈的情况等等。比如要显示变量floatPtr的值，输入命令`print floatPtr(p floatPtr)`便可以看到变量的值。继续运行程序：`continue（c）`，直到程序运行结束。
![2](http://github-blog.qiniudn.com/2014-02-10-gdb-debug-2.png-BlogPic)  

　　如果需要使用GDB调试已运行的程序，有两种方法：  
　　1、在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb <program> PID格式挂接正在运行的程序。  
　　2、先用gdb <program>关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。

　　这样我们对GDB的调试流程有了个大概的了解，接下来介绍一些常见的命令。
## 2 GDB基本命令 ##
　　gdb的命令很多，gdb把之分成如下多个种类。  
　　其中主要的种类包括：  
　　（1）breakpoints：断点设置类  
　　（2）data：　　　 数据查看类  
　　（3）files：　　　 指定并查看文件类   
　　（4）internals：　 维护命令类  
　　（5）running：　　程序执行类  
　　（6）stack：　　　调用栈查看类  
　　（7）status：　　 状态查看类  
　　（8）tracepoints：跟踪程序执行类  
　　help命令只是例出gdb的命令种类，如果要看种类中的命令，可以使用help <class> 命令，如：help breakpoints，查看设置断点的所有命令。也可以直接help <command>来查看命令的帮助。  
　　gdb中，输入命令时，可以不用打全命令，只用打命令的前几个字符就可以了，当然，命令的前几个字符应该要标志着一个唯一的命令，在Linux下，你可以敲击两次TAB键来补齐命令的全称，如果有重复的，那么gdb会把其例出来。  
　　在调试C++的程序时，因为C++允许重载，所以会出现多个函数函数名相同但是参数是不同类型的情况。这时候我们在函数名前面加上一个单引号`'`，提醒GDB在补全的时候需要考虑更多的信息，比如说： 
 
    (gdb) b 'bubble( M-? 
    bubble(double,double)    bubble(int,int)
    (gdb) b 'bubble(  
　　你可以查看到C++中的所有的重载函数及参数。（注：M-?和“按两次TAB键”是一个意思）   
　　GDB中比较重要的4类命令介绍：     
### 2.1 断点设置类相关命令  

　　主要用来在调试程序中设置断点。  
　　break 行号：在指定的行号上设置断点  
　　break 函数：在“函数”名所在的行设置断点，使程序恰好在进入指定的函数前停止  
　　info break：显示所有断点信息  
　　delete 断点号：表示将指定的断点号删除，如果不指定要删除的断点号，系统默认删除所有断点号，断点号可通过info break的第一栏查询  
　　disable 断点号：禁止指定的断点号，同delete一样，如果不指定断点号，则禁止当前文件下所有的断点  
　　enable 断点号：激活指定的断点号，即激活被disable禁止的断点  
　　ignore 断点号 num：在程序执行中，忽略对应断点num次  
　　tbreak 行号或函数：设置临时断点，程序执行一次后，断点被自动删除  
　　watch expression：设置一个表达式的观测点  
　　clear [FILE:]NUM: 删除设置在特定源文件或者特定行上的断点  
　　clear与delete都是清除断点，但是两者的区别在于，clear命令后面要给出清除的断点所在的行的行号，而delete命令是给出清除断点的编号；其次，使用clear命令清除断点时，gdb会自动给出提示，delete命令则不会。  
### 2.2 数据查看类相关命令

　　可以用来查看程序中变量及内存信息。  
　　display [expr]:在每次程序停止时自动显示对应表达式expr的内容  
　　delete display [expr]:取消每次程序停止时显示对应表达式expr的内容  
　　delete mem：删除内存区域中的内容  
　　disable display [expr]:程序停止时禁止显示指定表达式expr的内容  
　　undisplay [expr]：禁止显示指定表达式expr的内容  
　　enable display [expr]:激活禁止显示的表达式expr  
　　print [expr][name]：打印当前表达式或变量的内容    
　　whatis [name]：显示变量的数据类型      
　　ptype [name]：显示用户结构体的定义内容    
　　print的显示格式：  
　　/x　　按十六进制格式显示变量  
　　/d　　按十进制格式显示变量   
　　/u　　按十六进制格式显示无符号整型  
　　/o　　按八进制格式显示变量  
　　/t　　按二进制格式显示变量  
　　/a　　按十六进制格式显示变量  
　　/c　　按字符格式显示变量  
　　/f　　按浮点数格式显示变量  
　　dispaly可以用来设置一些自动显示的变量，当程序暂停时，或者用户单步跟踪时，这些变量的值将会自动显示；print只能显示当前用户指定的变量或者表达式的值，当程序下一次单步执行或者暂停时，不会显示上次设定变量的值。  
### 2.3 文件查看类命令

　　主要用于程序文件的查看以及程序的编辑。   
　　cd DIR：将工作目录设置在DIR下  
　　directory DIR：在搜寻源文件时也搜索DIR目录  
　　file File：表示加载指定文件File进gdb  
　　search 正则表达式及变量：向前搜索正则表达式及变量  
　　foward-search 正则表达式及变量：向前搜索正则表达式  
　　reverse-search 正则表达式及变量：向后搜说正则表达式  
　　pwd：打印当前工作目录  
　　path DIR:在搜索文件路径时也搜索DIR目录  
　　load file：在运行程序时，动态加载file文件  
　　list [行号][函数名]：列出对应于正在执行的程序的源文件内容，后面不加任何参数表示显示10行源文件内容。list也可使用其缩写形式l  
　　info line：显示加载到内存中的代码  
### 2.4 程序控制相关命令      
　　在使用GDB调试过程中大致分为3中状态：运行态、暂停态以及结束态，其中暂停态使程序暂停在某个断点处，它在程序调试中用的最多；结束态是用户调试完毕，要跳出gdb的状态，在此状态下无法查看各种变量的值；运行态是除暂停态和结束态之外的所有状态。  
　　run：表示执行程序  
　　continue：继续执行正在调试的程序，该命令用在程序由于处理信号或断点导致停止运行时  
　　interrupt：中断调试程序的执行  
　　next：单步调试程序，不进入子函数单步执行  
　　nexti：单步调试一条指令  
　　step：单步调试程序，进入子函数单步执行  
　　kill：终止正在调试的程序  
　　set args：当被调试程序开始运行时，设置程序的参数列表  
　　set environment：设置程序环境变量的值  
　　show args：显示一开始调试程序的参数列表  
　　set step-mode：设置单步运行的模式  
　　show step-mode：显示单步运行的模式  
　　finish：运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息  
　　until：结束当前循环  
　　make：在不退出gdb的前提下执行make命令  



## 3 查看运行时数据 ##
　　在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：  

    print <expr>
    print /<f> <expr>
　　<expr\>是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），<f>是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。

### 3.1 查看程序变量 ###
　　在GDB中，你可以随时查看以下三种变量的值：  
　　1、全局变量（所有文件可见的）  
　　2、静态全局变量（当前文件可见的）  
　　3、局部变量（当前作用域可见的）        
　　如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：
    
    file::variable
    function::variable
　　可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：
    
    p 'f2.c'::x
    
　　当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::” 是否C++的操作符，所以你不必担心在调试C++程序时会出现异常。
    
　　另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU的C/C++编译器GCC，你可以使用“-gstabs”选项来解决这个问题。关于编译器的参数，还请查看编译器的使用说明文档。
### 3.2 查看数组 ###
　　有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：  
     
    int *array = (int *) malloc (len * sizeof (int));
        
　　于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：  

    p *array@len

　　@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的：  
    
    (gdb) p *array@len
    $1 = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40}

　　如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。  

### 3.3 查看内存 ###
　　你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：
    
    x/<n/f/u> <addr> 
    
　　n、f、u是可选的参数。    
　　n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个单位地址的内容。  
　　f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i。  
　　u 表示每个单位的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替：b表示单字节每单位，h表示双字节每单位，w表示四字节每单位，g表示八字节每单位。当我们指定了单位字节长度后，GDB会从指内存定的内存地址开始，读写指定字节宽度，并把其当作一个值取出来。  
　　<addr>表示一个内存地址。
　　n/f/u三个参数可以一起使用。例如：命令：`x/3uh 0x54320` 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。

### 3.4 变量自动显示 ###
　　你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。
    
    display <expr> 
    display/<fmt> <expr> 
    display/<fmt> <addr>
    
　　expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。     
　　格式i和s同样被display支持，一个非常有用的命令是：
    
    display/i $pc
    
　　$pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的功能。  
　　下面是一些和display相关的GDB命令：
    
    undisplay <dnums...>
    delete display <dnums...>
　　删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）
    
    disable display <dnums...>
    enable display <dnums...>
　　disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。
    
    info display
　　查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。


## 4 改变程序的执行 ##
　　一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。  
### 4.1 修改变量值   ###
　　修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。如：
    
    (gdb) print x=4
    
　　x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。  
　　在某些时候，很有可能你的变量和GDB中的参数冲突，如：
    
    (gdb) whatis width
    type = double
    (gdb) p width
    $4 = 13
    (gdb) set width=47
    Invalid syntax in expression.

　　因为，set width是GDB的命令，所以，出现了“Invalid syntax in expression”的设置错误，此时，你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：
    
   (gdb) set var width=47
        
　　另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值时，最好都使用set var格式的GDB命令。
   

### 4.2 跳转执行 ###

　　一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的jump命令来完：
    
    jump <linespec>
　　指定下一条语句的运行点。<linespce>可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。
    
    jump <address>
　　这里的<address\>是代码行的内存地址。    
　　注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。  
　　熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如：
    
    set $pc = 0x485


### 4.3 产生信号量   ### 

　　使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。  
　　语法是：signal <singal>，UNIX的系统信号量通常从1到15。所以<singal>取值也在这个范围。single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。
   
### 4.4 强制函数返回 ###

　　如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回。
    
    return
    return <expression>
　　使用return命令取消当前函数的执行，并立即返回，如果指定了<expression>，那么该表达式的值会被认作函数的返回值。
    
    
### 4.5 强制调用函数 ###

    call <expr>
　　表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。  
　　另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返回值，并把该值存入历史数据中。

## 总结 ##
　　以上是自己在使用时的查阅信息的一个归纳汇总，主要参考这两篇博客：[http://blog.csdn.net/haoel/article/details/2879](http://blog.csdn.net/haoel/article/details/2879)和[http://www.cnblogs.com/nufangrensheng/p/3428052.html](http://www.cnblogs.com/nufangrensheng/p/3428052.html)，有兴趣的话可以点击进去看看，写的很详细。
 